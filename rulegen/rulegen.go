package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"regexp"
	"strings"
	"time"
)

func die(err error) {
	fmt.Fprintln(os.Stderr, err)
	os.Exit(1)
}

func reverse(a []string) {
	for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
		a[i], a[j] = a[j], a[i]
	}
}

type rule struct {
	valid     bool
	exception bool
	children  map[string]*rule
}

func (root *rule) add(rs string) {
	var exception = false

	if strings.HasPrefix(rs, "!") {
		rs = rs[1:]
		exception = true
	}

	labels := strings.Split(rs, ".")
	reverse(labels)

	current := root
	for _, l := range labels {
		if current.children == nil {
			current.children = make(map[string]*rule)
		}

		if _, exists := current.children[l]; !exists {
			current.children[l] = &rule{false, false, nil}
		}

		current = current.children[l]
	}

	current.valid = true
	current.exception = exception
}

func (rule *rule) code() string {
	var children = "nil"

	if len(rule.children) > 0 {

		parts := make([]string, 0, len(rule.children))
		for k, v := range rule.children {
			parts = append(parts, fmt.Sprintf("\n%q: %s", k, v.code()))
		}
		children = "\nmap[string]*rule{"
		children += strings.Join(parts, ",")
		children += "}"
	}

	return fmt.Sprintf("\n&rule{%t, %t, %s}", rule.valid, rule.exception, children)
}

func parse(reader io.Reader) (*rule, error) {

	root := &rule{false, false, nil}

	r := bufio.NewReader(reader)

	for {
		line, isPrefix, err := r.ReadLine()

		if err != nil {
			if err == io.EOF {
				break
			}
			return nil, err
		}

		if isPrefix {
			panic("FIXME: handle long lines")
		}

		str := strings.TrimSpace(string(line))
		if strings.HasPrefix(str, "//") {
			continue
		}

		root.add(str)
	}

	return root, nil
}

func extractLicense(data []byte) []byte {

	var licEnd = regexp.MustCompile(".*===BEGIN ICANN DOMAINS===.*")
	var lines [][]byte

	r := bufio.NewReader(bytes.NewReader(data))

	for {
		line, prefix, err := r.ReadLine()

		if err != nil {
			die(err)
		}

		if prefix {
			panic("FIXME: handle long lines")
		}

		if licEnd.Match(line) {
			break
		}

		lines = append(lines, line)
	}

	return bytes.Join(lines, []byte("\n"))
}

func fetch(src string) ([]byte, error) {
	rsp, err := http.Get(src)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	return ioutil.ReadAll(rsp.Body)
}

const (
	header   = "// autogenerated - editing is futile\n"
	source   = "http://mxr.mozilla.org/mozilla-central/source/netwerk/dns/effective_tld_names.dat?raw=1"
	ruledecl = `
type rule struct { 
	valid, exception bool 
	children map[string]*rule
}
`
)

var help = flag.Bool("help", false, "print help")
var outfile = flag.String("out", "-", "output file")

func main() {

	flag.Parse()

	if *help {
		flag.Usage()
		os.Exit(1)
	}

	var out = os.Stdout

	fmt.Fprintf(os.Stderr, "fetching '%s'\n", source)
	data, err := fetch(source)
	if err != nil {
		die(err)
	}

	fmt.Fprintf(os.Stderr, "output: '%s'\n", *outfile)
	root, err := parse(bytes.NewReader(data))
	if err != nil {
		die(err)
	}

	if *outfile != "-" {
		out, err = os.Create(*outfile)
		if err != nil {
			die(err)
		}
		defer out.Close()
	}

	out.WriteString(header)
	fmt.Fprintf(out, "// date: %s\n", time.Now().UTC().Format("2006-01-02"))
	fmt.Fprintf(out, "// src:  %s\n\n", source)
	out.Write(extractLicense(data))
	out.WriteString("\n\npackage psl\n")
	out.WriteString(ruledecl)
	out.WriteString("var pslRules = ")
	out.WriteString(root.code())

	return
}
